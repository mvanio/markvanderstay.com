{
  "hash": "7dca3cc9b06a743d2b6ff848ebfaecf0",
  "result": {
    "markdown": "---\ntitle: \"Viewing Twitter Influence With Network Graphs\"\nformat: \n  html:\n    fig-width: 8\n    fig-height: 6\neditor: visual\nexecute: \n  eval: false\nwebsite:\n  open-graph: true\n  image: \"https://markvanderstay.com/posts/twitter-analysis-of-retweets-with-r/main.jpeg\"\n  twitter-card: \n    description: \"Have you wondered how information spreads on Twitter?\"\n    image: \"https://markvanderstay.com/posts/twitter-analysis-of-retweets-with-r/main.jpeg\"\n    site: \"@m_vanders\"\n---\n\n\n![](main.jpeg){fig-alt=\"Twitter network graph with communities\" fig-align=\"center\" width=\"600\"}\n\n## What is a Network Graph?\n\nHave you wondered how information spreads on Twitter?\n\nNetwork analysis and visualisation are powerful tools that allow us to understand the structure of social relationships and quantify internet communities.\n\nIn network analysis of internet communities such as Twitter we gain a better understanding of social relationships and information flow between users. Retweets, for example, can be used to identify key influencers and measure the spread of information within a community.\n\nA network graph is a visual representation of the flow of information between network users.\n\n### Key terminology\n\nTwo key terms to understand are 'Vertices' and 'Edges'.\n\nVertices\n\n:   Also called 'nodes'. In the example that follows, a vertex is a Twitter user.\n\nEdges\n\n:   A pair relationship between two vertices. In this example our edges show who is being retweeted and by whom.\n\n## Twitter retweet network example\n\nBefore I visualise a network I consider the context and requirements. For example, do I want to:\n\n-   Assign colors to vertices based on some node attributes?\n\n-   Set the vertex size as a function of some attributes?\n\n-   Show all vertices?\n\nDeciding these answers early on saves time later.\n\nI'm going to demonstrate creating a network graph using the Twitter hashtag `#MushroomMonday`. It's a fine tag to follow. One of the finest. Lots of photos of fungi in all their splendour. And yes, fungi can be very varied just like the Twitter accounts that post mushroom content.\n\nI'll show that early on in the visualising process my graphs are usually messy. I think that's normal because it's normal for me. And because I've already decided I will eliminate some vertices then colour and resize the remainder, it's a fairly straightforward approach.\n\nMy method here is not the most straightforward. I use it to get a grasp on the network and the data in it. As ever, there's more than one way to achieve a goal.\n\n### 1. The setup\n\nObligatory libraries...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rtweet)\nlibrary(igraph)\n```\n:::\n\n\nThe very first thing to do is authorise `rtweet` to fetch tweets for you. The Twitter API is now available at a cost even if you only wish to read tweets. I know, I know, but what can we do?\n\nLuckily for me I saved the data for this particular graph earlier[^1]. I load it here.\n\n[^1]: If you'd like example data to practice on you can download a dataset from [Stanford University's SNAP](http://snap.stanford.edu/data/index.html#socnets).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The Twitter API is no longer allowing free access to read tweets. \n# If you've a paid up developer account you can use the search_tweets function like so...\n#\n# twts <- search_tweets(\"#MushroomMonday\", n = 1000, include_rts = TRUE)\n#\n# Otherwise you'll need to count on a file of graph you've saved previously.\n# Like I did.\n\ngml <- read_graph(\"./mushroommonday.graphml\", format = \"graphml\")\n```\n:::\n\n\nLet's check the output.\n\nA quick look at the edges...\n\n``` {.r .R}\n> edge_attr(gml)\n$type\n  [1] \"mention\" \"mention\" \"mention\" \"mention\" \"mention\" \"mention\" \"mention\" \"mention\" \"mention\" \"mention\" \"mention\" \"mention\"\n [13] \"mention\" \"mention\" \"mention\" \"mention\" \"mention\" \"mention\" \"mention\" \"mention\" \"mention\" \n```\n\nand vertices...\n\n``` r\n> vertex_attr(gml)\n$id\n  [1] \"72819944\"  \"1447502319944454148\" \"1430641982880239617\" \"36879139\"            \"1506195335579938818\"\n  [6] \"1407036811151556613\" \"2354121475\"  \"2216026806\"  \"1450456500418367490\" \"16872011\"           \n\n$name\n  [1] \"bernoid\"  \"ada_apocalypse\"  \"ThatFellaCrafty\" \"marypele\"        \"Cottage_C_Craft\"  \"LizLouise12\"    \n  [7] \"coachmegjade\"  \"PacificRimNPR\"  \"LukesMushrooms\"  \"LGTrombatore\"  \"fun_g4l\"         \"Whatknotsartist\"\n [13] \"LX8111\"  \"MacroMarie\"  \"GreatLakesFungi\" \"TanukisRevenge\"  \"muscariamadge\"   \"ray_rambling\"   \n [19] \"TheSuffolkMan\"  \"keeper_of_books\" \"BobJoostens\"  \"TheWitchersOne\"  \"\n \n```\n\nNot a lot to see so I'll try a quick plot.\n\n### 2. First plot is the messiest. Always.\n\n``` r\nset.seed(127926)\nplot(gml,  layout = layout.fruchterman.reingold)\n```\n\nHmmm. Not pretty.\n\n![Poor effort. Needs work.](Rplot.jpeg){fig-align=\"left\" width=\"600\"}\n\nThe plot is crowded and I can't read the labels. The vertices have a `name` attribute which is the user's Twitter handle. Every vertex is the same size and colour.\n\nIt doesn't convey any information at all.\n\nIt's useless.\n\nThe connections between the vertices are barely visible. These faint lines are the edges.\nThey have only one attribute, `type`, which shows if the tweet was a mention, reply or retweet.\n\nI'll change all that now.\n\nI'll start by filtering out the replies and mentions. Retweets only beyond this point.\n\n``` r\n# Keep only retweets\ngml <- gml - E(gml)[E(gml)$type == \"retweet\"]\n```\n\nAnd locate the vertices with the most edges by assigning each edge a `weight` and summing the weights for each vertex.\n\n``` r\n# Find out who has the most edges\n## Set a default edge weight\nE(gml)$weight <- 1\n\n## Calculate the strength of each vertex\nV(gml)$strength <- strength(\n  gml,\n  vids = V(gml),\n  mode = \"total\",\n  loops = TRUE,\n  weights = NULL\n)\n```\n\nUsers that have had tweets retweeted the most have the highest values for `strength`.\n\n``` r\n# > V(gml)$strength\n# [1] 54  9 10 36  2  2  3  2  8  2 83  2  6  2 63 46 16 18 49 34  1  2  8  2  1 12  2  2  6  2 22  2  6  3  2 21  2 12 12 58  4 20 12 16 10  4  7\n```\n\n``` r\n> hist(V(gml)$strength)\n```\n\n![](Rplot01.jpeg){fig-align=\"left\"}\n\nThere's quite a mixture of strength values here and I'm only interested in the strongest nodes.\n\n``` r\n# Remove vertices that do not meet the mean strength value\n#  - Create a subgraph of vertices that don't meet threshold strength\ngmls <- subgraph(gml, which(V(gml)$strength >= mean(V(gml)$strength)))\n\n# remove isolated vertices (with no edges)\nisolated = which(degree(gmls, mode = \"total\")==0)\ngmls = delete.vertices(gmls, isolated)\n```\n\nAnd I can keep labels only for those who are the highest performing vertices. It may mean that there are some unlabelled nodes but that shouldn't be a problem because they're not important.\n\n``` r\n# Keep labels only for vertices with the highest strength\nV(gmls)$label <- ifelse(V(gmls)$strength > 14, V(gmls)$name, NA)\n```\n\nIt would be useful to sneak a quick peek at what I'm left with. I'm using a force-directed layout and I'd like to have some space between vertices. First things first, I'll reset the edge weights to a very small value. Since the edge weights are the force responsible for holding the vertices together, a smaller weight should give me what I'm after.\n\n``` r\n# Reset edge weights to spread out the graph\nE(gmls)$weight <- E(gmls)$weight/100000\n\n# Plot for another look-see\nset.seed(127926)\nplot(gmls,\n     layout = layout.fruchterman.reingold, \n     vertex.size = 5,  \n     edge.arrow.size = 0.25)\n```\n\n![Getting there.](rPlot03.png){fig-align=\"left\"}\n\n### 3. Changing vertex size and colour\n\nI can work with the graph above. It's time to start making the plot presentable.\n\nI'll change the vertex size as a function of `strength`. The higher the vertex's strength, the larger it will be.\n\nColour is also vital now. I pick a palette using the RColorBrewer library and choose one that I think is close to the colours of Turkey Tail mushrooms. I think the folks in #MushroomMonday would like it.\n\n``` r\n# Now we're close. Let's change the vertex size depending on strength and add colour.\n# Vertex size will indicate the amount of retweets by other users, it will be a function of strength.\n\nlibrary(RColorBrewer)\n\ncol <- brewer.pal(5, \"RdPu\")\n```\n\n``` r\nfor(v in V(gmls)){\n  # Colour from light to dark\n  if (V(gmls)$strength[v] < 15){\n    V(gmls)$s_class[v] <- 3\n  } else if (V(gmls)$strength[v] < 30){\n    V(gmls)$s_class[v] <- 4\n  } else\n    V(gmls)$s_class[v] <- 5\n}\n```\n\n``` r\nset.seed(127926)\n\nplot(gmls,\n     layout = layout.fruchterman.reingold, \n     vertex.label = V(gmls)$label, \n     vertex.label.color = col[V(gmls)$s_class],\n     vertex.label.cex=0.8,\n     vertex.label.dist = -1.6,\n     vertex.label.degree = -pi/2,\n     vertex.size = sqrt(V(gmls)$strength)*2.4,\n     vertex.color = col[V(gmls)$s_class],\n     vertex.frame.color = col[1],\n     edge.curved = 0.3,\n     edge.arrow.size = 0.25,\n     edge.color = col[2])\n```\n\n![](Rplot04.jpeg)\n\nOK, so it more 'fairy princess' than Turkey Tail but it tells a story. The users who are retweeted more than most are are the darkest purple, while the weakest nodes - those with lower values of \\`strength\\` are smaller, pinker and unlabelled.\n\nIf I wanted my tweets to be noticed by others I'd hope that they were retweeted by one of the stronger accounts.\n\nTrouble is that hope really doesn't get you anywhere.\n\n### 4. Visualising cliques and communities\n\nSo how can you increase your chances of being noticed? You could follow all of the accounts, sure. But Twitter penalises tweets from accounts with a high following:follower ratio, so you need to be selective. Which accounts will get you the biggest return on investment then?\n\nLet's look at the communities.\n\nUsers in the same cluster, or clique, are more connected with one another that users outside of the cluster. This will tell me if there are divisions due to different types of account. Put another way in our fungi example, there may be accounts that prefer scientific data and accounts that prefer photographic content. This info shows up in separate clusters.\n\nA small tweak to my graph and I notice that there is a split between the interesting accounts.\n\nTake a look for yourself below. The nodes are now coloured according to the clusters they belong to. Green, orange and blue nodes are in different clusters. Our strong accounts are now split three ways. I would go on to check the content of these communities and determine which accounts are more suited for my client.\n\n![](main.jpeg)\n\n### 5. Conclusion\n\n#### a. What improvements would I make to the code?\n\nGraphs that are more cluttered often benefit from an interactive visualisation or application. This isn't one of them.\nThis is such a simple example I probably won't make any adjustments of note. \n\nIn order to demonstrate the most basic concepts of network graphs I've steered clear of using `coreness` and plotting `k-core`. I'd normally use those myself instead of summing vertex strength but either approach works.\n\nYMMV.\n\n#### b. How should I interpret this graph for my client?\n\nOpinions are like.. well, never mind. Here's mine. The graph informs us that:\n\n1.  There are multiple strong accounts that will be worth pursuing as influencers\n2.  Those accounts are in different clusters\n3.  The cluster with content most similar to the client's is likely to have followers with similar interests\n4.  To gain engagement, the followers of the cluster's main account(s) should be followed to engage with our content\n\nAll in all this has been a worthwhile exercise to save tweeting into the void.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}